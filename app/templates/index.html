<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support Desk</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="/static/style.css">
    <script src="/static/navigation.js"></script>
    <script src="/static/menu_loader.js"></script>
    <script src="/static/notification.js"></script>
</head>
<body>
    <div class="layout">
        <!-- Top Navigation Bar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <a href="/" style="text-decoration: none; color: inherit;">
                    <h1>Support Desk</h1>
                </a>
            </div>
            
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <div class="main-nav" id="mainNav">
                        <!-- Меню загружается динамически -->
                    </div>
                </div>
            </div>
            
            <div class="sidebar-footer">
                <form id="logoutForm" method="post" action="/logout">
                    <button type="submit" class="logout-btn">
                        <span class="material-icons">logout</span>
                        <span class="btn-text">Выйти</span>
                    </button>
                </form>
            </div>
        </aside>
        
        <!-- Основной контент с двумя колонками: левая - список чатов, правая - чат -->
        <main class="main-content chat-page">
            <!-- Левая колонка со списком заявок -->
            <div class="tickets-sidebar">
                <div class="sidebar-section">
                    <div class="tabs">
                        <button id="activeTab" class="tab-button active" data-tab="active">
                            <span class="material-icons">check_circle</span>
                            <span class="btn-text">Активные</span>
                        </button>
                        <button id="archivedTab" class="tab-button" data-tab="archived">
                            <span class="material-icons">archive</span>
                            <span class="btn-text">Архив</span>
                        </button>
                    </div>
                </div>
                
                <ul id="conversations" class="conversation-list"></ul>
            </div>
            
            <!-- Правая колонка с контентом чата -->
            <div class="chat-content-wrapper">
                <section id="placeholder" class="placeholder">
                    <p>Выберите активную заявку для продолжения.</p>
                </section>
                <section id="chatPanel" class="chat chat-panel hidden">
                    <div class="chat-top">
                        <header class="chat-panel__header">
                            <h2 id="chatTitle">Заявка</h2>
                            <div id="unreadBadge" class="unread-counter hidden"></div>
                            <button id="finishButton" type="button" class="btn-end-game">
                                <span class="btn-label">Завершить заявку</span>
                            </button>
                        </header>
                        <div id="summaryPanel" class="summary-panel">
                            <div class="summary-header">
                                <span class="material-icons">description</span>
                                <span class="summary-title">Краткое содержание</span>
                            </div>
                            <div id="summaryContent" class="summary-content">
                                <div class="summary-loading">Загрузка саммари...</div>
                            </div>
                        </div>
                    </div>
                    <div id="messages" class="messages"></div>
                <form id="replyForm" class="reply-form" autocomplete="off">
                    <div class="message-input-container">
                        <textarea id="messageInput" placeholder="Ответьте клиенту" required rows="1"></textarea>
                        <button type="submit" class="send-button" title="Отправить (Enter)">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                            </svg>
                        </button>
                    </div>
                </form>
            </section>
            </div>
        </main>
    </div>

    <script>
        const conversationsList = document.getElementById('conversations');
        const messagesContainer = document.getElementById('messages');
        const chatTitle = document.getElementById('chatTitle');
        const unreadBadge = document.getElementById('unreadBadge');
        const replyForm = document.getElementById('replyForm');
        const messageInput = document.getElementById('messageInput');
        const placeholder = document.getElementById('placeholder');
        const chatPanel = document.getElementById('chatPanel');
        const finishButton = document.getElementById('finishButton');
        const activeTab = document.getElementById('activeTab');
        const archivedTab = document.getElementById('archivedTab');
        const summaryPanel = document.getElementById('summaryPanel');
        const summaryContent = document.getElementById('summaryContent');

        const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        let conversationSocket = null;
        let chatSocket = null;
        let conversations = [];
        let activeConversationId = null;
        let markingRead = false;
        let currentTab = 'active';
        
        // Экспортируем activeConversationId в глобальную область для notification.js
        window.getActiveConversationId = () => activeConversationId;
        
        // Telegram-style notification sound - используем AudioContext для надежности
        let audioContext = null;
        let notificationBuffer = null;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Создаем простой beep звук программно
                const duration = 0.15;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Генерируем синусоидальный звук (800 Hz)
                const frequency = 800;
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * frequency * t) * Math.exp(-t * 8);
                }
                notificationBuffer = buffer;
            } catch (e) {
                console.log('Audio initialization failed:', e);
            }
        }
        
        function playNotificationSound() {
            try {
                if (!audioContext) {
                    initAudio();
                }
                if (audioContext && notificationBuffer) {
                    const source = audioContext.createBufferSource();
                    source.buffer = notificationBuffer;
                    
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0.3; // Громкость 30%
                    
                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start(0);
                    
                    console.log('Notification sound played');
                }
            } catch (e) {
                console.log('Sound play failed:', e);
            }
        }
        
        // Инициализируем аудио при первом клике пользователя
        document.addEventListener('click', function initOnClick() {
            initAudio();
            document.removeEventListener('click', initOnClick);
        }, { once: true });

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            // Всегда показываем дату И время
            const timeStr = date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            const dateStr = date.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit', year: 'numeric' });
            
            return `${dateStr} ${timeStr}`;
        }

        function closeChatSocket() {
            if (chatSocket) {
                chatSocket.close();
                chatSocket = null;
            }
        }

        function hideChatPanel() {
            closeChatSocket();
            activeConversationId = null;
            chatPanel.classList.add('hidden');
            placeholder.classList.remove('hidden');
            replyForm.reset();
            
            // Возвращаем URL на список заявок
            history.pushState({}, '', '/tickets');
        }

        function renderConversations(conversationsData) {
            conversations = conversationsData;
            if (activeConversationId && !conversations.some((item) => item.id === activeConversationId)) {
                hideChatPanel();
            }

            conversationsList.innerHTML = '';
            
            // Фильтруем по текущему табу
            const filteredConversations = conversations.filter(conversation => {
                // ВАЖНО: показываем ТОЛЬКО тикеты где запрошен оператор
                if (!conversation.operator_requested) {
                    return false;
                }
                
                if (currentTab === 'active') {
                    // Активные: open и in_progress
                    return conversation.status === 'open' || conversation.status === 'in_progress';
                } else {
                    // Архив: closed и archived
                    return conversation.status === 'closed' || conversation.status === 'archived';
                }
            });

            if (!filteredConversations.length) {
                conversationsList.innerHTML = '<li class="empty-state">Нет заявок</li>';
                if (activeConversationId) {
                    hideChatPanel();
                }
                return;
            }

            filteredConversations.forEach((conversation) => {
                const item = document.createElement('li');
                item.dataset.id = conversation.id;
                item.classList.add('conversation-item');

                if (conversation.id === activeConversationId) {
                    item.classList.add('active');
                }

                const content = document.createElement('div');
                content.className = 'conversation-content';

                const title = document.createElement('div');
                title.className = 'conversation-title';
                
                // Добавляем счетчик непрочитанных в заголовок
                if (conversation.unread_count > 0) {
                    title.textContent = `Заявка #${conversation.id} (${conversation.unread_count})`;
                } else {
                    title.textContent = `Заявка #${conversation.id}`;
                }

                const meta = document.createElement('div');
                meta.className = 'conversation-meta';
                
                // Время создания
                const createdTime = document.createElement('div');
                createdTime.className = 'conversation-time';
                createdTime.textContent = `Создано: ${formatTimestamp(conversation.created_at)}`;
                
                // Время последнего сообщения
                const updatedTime = document.createElement('div');
                updatedTime.className = 'conversation-time';
                updatedTime.textContent = `Обновлено: ${formatTimestamp(conversation.updated_at)}`;
                
                meta.appendChild(createdTime);
                meta.appendChild(updatedTime);
                
                // Добавляем приоритет
                if (conversation.priority) {
                    const priorityLabels = {
                        'high': 'Высокий',
                        'medium': 'Средний',
                        'low': 'Низкий'
                    };
                    const priorityColors = {
                        'high': '#ff4444',
                        'medium': '#ffaa00',
                        'low': '#4CAF50'
                    };
                    const priorityIcons = {
                        'high': '⬆️',
                        'medium': '➡️',
                        'low': '⬇️'
                    };
                    
                    const priorityDiv = document.createElement('div');
                    priorityDiv.className = 'conversation-priority';
                    priorityDiv.style.cssText = `
                        display: inline-block;
                        padding: 2px 8px;
                        border-radius: 12px;
                        font-size: 11px;
                        font-weight: 500;
                        margin-top: 4px;
                        background-color: ${priorityColors[conversation.priority]}20;
                        color: ${priorityColors[conversation.priority]};
                        border: 1px solid ${priorityColors[conversation.priority]};
                    `;
                    priorityDiv.textContent = `${priorityIcons[conversation.priority]} ${priorityLabels[conversation.priority]}`;
                    meta.appendChild(priorityDiv);
                }

                content.appendChild(title);
                content.appendChild(meta);

                item.appendChild(content);

                if (conversation.unread_count > 0 && conversation.id !== activeConversationId) {
                    const badge = document.createElement('span');
                    badge.className = 'conversation-badge';
                    badge.textContent = conversation.unread_count > 99 ? '99+' : conversation.unread_count;
                    item.appendChild(badge);
                    item.classList.add('unread');
                }

                item.addEventListener('click', () => toggleConversation(conversation.id));
                conversationsList.appendChild(item);
            });
        }

        function renderMessages(messages) {
            messagesContainer.innerHTML = '';
            
            // Группируем сообщения по отправителю
            let lastSender = null;
            let lastTimestamp = null;
            
            messages.forEach((message, index) => {
                const nextMessage = messages[index + 1];
                const isSameSender = lastSender === message.sender;
                const timeDiff = lastTimestamp ? (new Date(message.created_at) - new Date(lastTimestamp)) / 1000 : Infinity;
                const isGrouped = isSameSender && timeDiff < 60; // Группировать если меньше 60 секунд
                
                const isLastInGroup = !nextMessage || 
                                     nextMessage.sender !== message.sender ||
                                     (new Date(nextMessage.created_at) - new Date(message.created_at)) / 1000 >= 60;
                
                appendMessage(message, isGrouped, isLastInGroup);
                
                lastSender = message.sender;
                lastTimestamp = message.created_at;
            });
            
            scrollMessagesToBottom();
        }

        function appendMessage(message, isGrouped = false, isLastInGroup = true) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message chat-message-${message.sender}`;
            
            // Добавляем классы для группировки
            if (isGrouped) {
                messageDiv.classList.add('grouped');
            }
            if (isLastInGroup) {
                messageDiv.classList.add('last-in-group', 'show-avatar');
            }
            
            // Выбираем иконку и имя в зависимости от отправителя
            let icon = 'person';
            let senderName = '';
            switch(message.sender) {
                case 'user':
                    icon = 'person';
                    senderName = message.username || 'Пользователь';
                    break;
                case 'bot':
                    icon = 'smart_toy';
                    senderName = 'Бот-помощник';
                    break;
                case 'operator':
                    icon = 'support_agent';
                    senderName = 'Оператор';
                    break;
            }
            
            messageDiv.innerHTML = `
                <div class="message-avatar"><span class="material-icons">${icon}</span></div>
                <div class="message-content">
                    <div class="message-sender-name">${senderName}</div>
                    <div class="message-text">${message.text}</div>
                    <div class="message-meta">${formatTimestamp(message.created_at)}</div>
                </div>
            `;
            
            messagesContainer.appendChild(messageDiv);
        }

        function scrollMessagesToBottom() {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function showTypingIndicator(sender) {
            // Удаляем предыдущий индикатор если есть
            removeTypingIndicator();
            
            let icon = 'person';
            switch(sender) {
                case 'user':
                    icon = 'person';
                    break;
                case 'bot':
                    icon = 'smart_toy';
                    break;
                case 'operator':
                    icon = 'support_agent';
                    break;
            }
            
            const typingDiv = document.createElement('div');
            typingDiv.className = `typing-indicator chat-message-${sender}`;
            typingDiv.innerHTML = `
                <div class="message-avatar"><span class="material-icons">${icon}</span></div>
                <div class="message-content">
                    <div class="typing-bubble">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            `;
            
            messagesContainer.appendChild(typingDiv);
            scrollMessagesToBottom();
        }
        
        function removeTypingIndicator() {
            const typingIndicator = messagesContainer.querySelector('.typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        async function loadConversations() {
            try {
                const url = currentTab === 'archived' ? '/api/conversations?archived=true' : '/api/conversations';
                const response = await fetch(url, { credentials: 'same-origin' });
                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (!response.ok) {
                    throw new Error('Не удалось загрузить список диалогов');
                }
                const data = await response.json();
                renderConversations(data);
            } catch (error) {
                console.error(error);
            }
        }

        async function loadMessages(conversationId) {
            try {
                const response = await fetch(`/api/conversations/${conversationId}/messages`, {
                    credentials: 'same-origin',
                });
                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (response.status === 403) {
                    hideChatPanel();
                    return;
                }
                if (!response.ok) {
                    throw new Error('Не удалось загрузить сообщения');
                }
                const messages = await response.json();
                if (conversationId !== activeConversationId) {
                    return;
                }
                renderMessages(messages);
                await markConversationRead(conversationId);
            } catch (error) {
                console.error(error);
            }
        }

        async function markConversationRead(conversationId) {
            if (markingRead) {
                return;
            }
            const conversation = conversations.find((item) => item.id === conversationId);
            if (!conversation || conversation.unread_count === 0) {
                return;
            }
            markingRead = true;
            try {
                const response = await fetch(`/api/conversations/${conversationId}/read`, {
                    method: 'POST',
                    credentials: 'same-origin',
                });
                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (response.status === 403) {
                    hideChatPanel();
                    await loadConversations();
                    return;
                }
                if (!response.ok) {
                    throw new Error('Не удалось обновить статус прочтения');
                }
                const updated = await response.json();
                const index = conversations.findIndex((item) => item.id === updated.id);
                if (index !== -1) {
                    conversations[index] = updated;
                    renderConversations([...conversations]);
                }
            } catch (error) {
                console.error(error);
            } finally {
                markingRead = false;
            }
        }

        function toggleConversation(conversationId) {
            if (activeConversationId === conversationId) {
                hideChatPanel();
                renderConversations(conversations);
                // URL уже обновлен в hideChatPanel()
                return;
            }
            selectConversation(conversationId);
        }

        async function selectConversation(conversationId) {
            const conversation = conversations.find((item) => item.id === conversationId);
            if (!conversation) {
                console.warn(`Conversation #${conversationId} not found`);
                return;
            }
            activeConversationId = conversationId;
            // Подавляем уведомления для этого чата на короткое время — чтобы избежать гонок
            try {
                window.suppressNotificationFor = conversationId;
                setTimeout(() => {
                    if (window.suppressNotificationFor === conversationId) {
                        window.suppressNotificationFor = null;
                    }
                }, 1500);
            } catch (e) {
                // ignore in environments where window isn't writable
            }
            
            // Изменяем URL на /tickets/ID
            history.pushState({ conversationId }, '', `/tickets/${conversationId}`);
            
            const titleText = conversation.title || `Заявка #${conversation.id}`;
            chatTitle.textContent = titleText;
            
            // Показываем счетчик непрочитанных в заголовке
            if (conversation.unread_count > 0) {
                unreadBadge.textContent = conversation.unread_count;
                unreadBadge.classList.remove('hidden');
            } else {
                unreadBadge.classList.add('hidden');
            }
            
            placeholder.classList.add('hidden');
            chatPanel.classList.remove('hidden');
            
            // Показываем/скрываем кнопку завершения в зависимости от статуса заявки
            const isArchived = conversation.status === 'closed' || conversation.status === 'archived';
            if (isArchived) {
                finishButton.style.display = 'none';
                replyForm.style.display = 'none'; // Скрываем форму ответа для архивных диалогов
            } else {
                finishButton.style.display = 'block';
                replyForm.style.display = 'block';
            }
            
            renderConversations(conversations);
            connectChatSocket(conversationId);
            loadTicketSummary(conversationId);
            await loadMessages(conversationId);
        }

        function connectChatSocket(conversationId) {
            closeChatSocket();
            const url = `${wsProtocol}://${window.location.host}/ws/conversations/${conversationId}`;
            chatSocket = new WebSocket(url);
            
            let typingTimeout = null;

            chatSocket.onmessage = (event) => {
                const payload = JSON.parse(event.data);
                if (payload.type === 'history' && payload.conversation_id === activeConversationId) {
                    renderMessages(payload.messages);
                    markConversationRead(conversationId);
                }
                if (payload.type === 'message' && payload.conversation_id === activeConversationId) {
                    // Определяем, нужно ли группировать с предыдущим сообщением
                    const allMessages = Array.from(messagesContainer.querySelectorAll('.chat-message:not(.typing-indicator)'));
                    const lastMessage = allMessages[allMessages.length - 1];
                    
                    let isGrouped = false;
                    let isLastInGroup = true;
                    
                    if (lastMessage) {
                        const lastSender = lastMessage.classList.contains('chat-message-user') ? 'user' :
                                          lastMessage.classList.contains('chat-message-operator') ? 'operator' :
                                          lastMessage.classList.contains('chat-message-bot') ? 'bot' : null;
                        
                        const isSameSender = lastSender === payload.message.sender;
                        
                        // Проверяем время между сообщениями
                        const lastMetaElement = lastMessage.querySelector('.message-meta');
                        if (lastMetaElement && isSameSender) {
                            isGrouped = true;
                            // Удаляем класс show-avatar у предыдущего сообщения
                            lastMessage.classList.remove('show-avatar', 'last-in-group');
                            lastMessage.classList.add('grouped');
                        }
                    }
                    
                    removeTypingIndicator();
                    appendMessage(payload.message, isGrouped, isLastInGroup);
                    scrollMessagesToBottom();
                    markConversationRead(conversationId);
                    
                    // Играем звук если сообщение не от оператора
                    if (payload.message.sender !== 'operator') {
                        playNotificationSound();
                    }
                }
                
                // Typing indicator
                if (payload.type === 'typing' && payload.conversation_id === activeConversationId) {
                    showTypingIndicator(payload.sender);
                    
                    clearTimeout(typingTimeout);
                    typingTimeout = setTimeout(() => {
                        removeTypingIndicator();
                    }, 3000);
                }
                
                if (payload.type === 'stop_typing' && payload.conversation_id === activeConversationId) {
                    removeTypingIndicator();
                }
            };

            chatSocket.onclose = (event) => {
                if (event.code === 4401) {
                    window.location.href = '/login';
                    return;
                }
                if (activeConversationId === conversationId) {
                    setTimeout(() => connectChatSocket(conversationId), 2000);
                }
            };
        }

        async function sendReply(event) {
            event.preventDefault();
            if (!activeConversationId) {
                return;
            }
            const text = messageInput.value.trim();
            if (!text) {
                return;
            }
            try {
                const response = await fetch(`/api/conversations/${activeConversationId}/reply`, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text }),
                });
                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (response.status === 403) {
                    hideChatPanel();
                    await loadConversations();
                    return;
                }
                if (!response.ok) {
                    const detail = await response.json().catch(() => ({}));
                    throw new Error(detail.detail || 'Ошибка отправки сообщения');
                }
                messageInput.value = '';
            } catch (error) {
                alert(error.message);
            }
        }

        async function finishConversation() {
            if (!activeConversationId) {
                return;
            }
            finishButton.disabled = true;
            try {
                const response = await fetch(`/api/conversations/${activeConversationId}/finish`, {
                    method: 'POST',
                    credentials: 'same-origin',
                });
                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (!response.ok) {
                    const detail = await response.json().catch(() => ({}));
                    throw new Error(detail.detail || 'Не удалось завершить диалог');
                }
                hideChatPanel();
            } catch (error) {
                alert(error.message);
            } finally {
                finishButton.disabled = false;
            }
        }

        function initConversationsSocket() {
            const url = `${wsProtocol}://${window.location.host}/ws/conversations`;
            conversationSocket = new WebSocket(url);

            conversationSocket.onmessage = (event) => {
                const payload = JSON.parse(event.data);
                if (payload.type === 'conversations') {
                    renderConversations(payload.conversations);
                }
            };

            conversationSocket.onclose = (event) => {
                if (event.code === 4401) {
                    window.location.href = '/login';
                    return;
                }
                setTimeout(initConversationsSocket, 2000);
            };
        }

        // Обработчики для переключения вкладок
        function switchTab(tabName) {
            currentTab = tabName;
            
            // Обновляем активную вкладку
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            if (tabName === 'active') {
                activeTab.classList.add('active');
                placeholder.innerHTML = '<p>Выберите активную заявку для продолжения.</p>';
            } else {
                archivedTab.classList.add('active');
                placeholder.innerHTML = '<p>Выберите архивную заявку для продолжения.</p>';
            }
            
            // Скрываем чат при переключении вкладок
            hideChatPanel();
            
            // Загружаем диалоги для выбранной вкладки
            loadConversations();
        }

        activeTab.addEventListener('click', () => switchTab('active'));
        archivedTab.addEventListener('click', () => switchTab('archived'));

        replyForm.addEventListener('submit', sendReply);
        finishButton.addEventListener('click', finishConversation);
        
        // Автоматическое изменение размера textarea
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });
        
        // Отправка по Enter (без Shift)
        messageInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendReply(event);
            }
        });
        
        window.addEventListener('beforeunload', closeChatSocket);
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                hideChatPanel();
                renderConversations(conversations);
                // URL уже обновлен в hideChatPanel()
            }
        });
        
        // Обработка кнопки "назад" в браузере
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.conversationId) {
                // Если в истории есть ID разговора, открываем его
                selectConversation(event.state.conversationId);
            } else {
                // Иначе закрываем чат и показываем список
                hideChatPanel();
                renderConversations(conversations);
            }
        });

        // Функции для работы с саммари
        async function loadTicketSummary(conversationId) {
            summaryContent.innerHTML = '<div class="summary-loading">Загрузка саммари...</div>';
            
            try {
                const response = await fetch(`/api/conversations/${conversationId}/summary`);
                if (!response.ok) {
                    throw new Error('Failed to load summary');
                }
                
                const data = await response.json();
                displaySummary(data.summary, data.classification, data.priority);
            } catch (error) {
                console.error('Error loading summary:', error);
                summaryContent.innerHTML = '<div class="summary-error">Ошибка загрузки саммари</div>';
            }
        }

        function displaySummary(summary, classification, priority) {
            let html = `<div class="summary-text">${summary}</div>`;
            
            if (classification) {
                html += `<div class="classification-container">
                    <div class="classification-header">🏷️ Классификация проблемы:</div>
                    <div class="classification-tags">`;
                
                // Разбиваем классификацию на отдельные теги
                const categories = classification.split(',').map(cat => cat.trim());
                categories.forEach(category => {
                    html += `<span class="classification-tag">${category}</span>`;
                });
                
                html += `</div></div>`;
            }
            
            // Добавляем приоритет
            if (priority) {
                const priorityLabels = {
                    'low': 'Низкий',
                    'medium': 'Средний',
                    'high': 'Высокий'
                };
                const priorityColors = {
                    'low': '#4caf50',
                    'medium': '#ff9800',
                    'high': '#f44336'
                };
                const priorityIcons = {
                    'low': '⬇️',
                    'medium': '➡️',
                    'high': '⬆️'
                };
                
                const label = priorityLabels[priority] || priority;
                const color = priorityColors[priority] || '#999';
                const icon = priorityIcons[priority] || '•';
                
                html += `<div class="priority-container">
                    <div class="priority-header">${icon} Приоритет:</div>
                    <span class="priority-badge" style="background-color: ${color}20; color: ${color}; border: 1px solid ${color};">
                        ${label}
                    </span>
                </div>`;
            }
            
            summaryContent.innerHTML = html;
        }
        
        // Инициализация роутинга при загрузке страницы
        function initializeRouting() {
            const path = window.location.pathname;
            const match = path.match(/\/tickets\/(\d+)/);
            
            if (match) {
                const ticketId = parseInt(match[1]);
                console.log(`🔗 Opening ticket from URL: ${ticketId}`);

                async function tryOpenTicket(attempt = 1) {
                    let conversation = conversations.find(c => c.id === ticketId);
                    if (conversation) {
                        // Определяем к какой категории относится тикет
                        const isArchived = conversation.status === 'closed' || conversation.status === 'archived';
                        // Переключаем на нужный таб ПЕРЕД открытием
                        if (isArchived && currentTab !== 'archived') {
                            console.log(`📂 Switching to archived tab for ticket #${ticketId}`);
                            currentTab = 'archived';
                            archivedTab.classList.add('active');
                            activeTab.classList.remove('active');
                        } else if (!isArchived && currentTab !== 'active') {
                            console.log(`📂 Switching to active tab for ticket #${ticketId}`);
                            currentTab = 'active';
                            activeTab.classList.add('active');
                            archivedTab.classList.remove('active');
                        }
                        renderConversations(conversations);
                        selectConversation(ticketId);
                    } else if (attempt < 10) {
                        // Пробуем еще раз через 100мс, максимум 10 попыток
                        setTimeout(() => { tryOpenTicket(attempt + 1); }, 100);
                    } else {
                        // Если тикет так и не найден локально, пробуем подгрузить его с сервера
                        try {
                            const resp = await fetch(`/api/conversations/${ticketId}`, { credentials: 'same-origin' });
                            if (resp.status === 401) {
                                window.location.href = '/login';
                                return;
                            }
                            if (resp.ok) {
                                let conv = await resp.json();
                                // Нормализуем минимально необходимые поля
                                conv.unread_count = conv.unread_count || 0;
                                conv.status = conv.status || 'closed';
                                conv.created_at = conv.created_at || new Date().toISOString();
                                conv.updated_at = conv.updated_at || conv.created_at;
                                // Добавляем в локальный массив, обновляем список и открываем
                                conversations.push(conv);
                                const isArchived = conv.status === 'closed' || conv.status === 'archived';
                                if (isArchived && currentTab !== 'archived') {
                                    currentTab = 'archived';
                                    archivedTab.classList.add('active');
                                    activeTab.classList.remove('active');
                                } else if (!isArchived && currentTab !== 'active') {
                                    currentTab = 'active';
                                    activeTab.classList.add('active');
                                    archivedTab.classList.remove('active');
                                }
                                renderConversations(conversations);
                                selectConversation(ticketId);
                                return;
                            }
                        } catch (e) {
                            console.error('Error fetching conversation by id:', e);
                        }
                        console.warn(`❌ Ticket #${ticketId} not found after retries and server fetch, redirecting to list`);
                        history.replaceState({}, '', '/tickets');
                    }
                }
                tryOpenTicket();
            }
        }
        
        // Обработка кнопок браузера назад/вперед
        window.addEventListener('popstate', (event) => {
            const path = window.location.pathname;
            const match = path.match(/\/tickets\/(\d+)/);
            
            if (match) {
                const ticketId = parseInt(match[1]);
                let conversation = conversations.find(c => c.id === ticketId);
                
                if (conversation) {
                    // Определяем к какой категории относится тикет
                    const isArchived = conversation.status === 'closed' || conversation.status === 'archived';
                    
                    // Переключаем на нужный таб
                    if (isArchived && currentTab !== 'archived') {
                        currentTab = 'archived';
                        archivedTab.classList.add('active');
                        activeTab.classList.remove('active');
                    } else if (!isArchived && currentTab !== 'active') {
                        currentTab = 'active';
                        activeTab.classList.add('active');
                        archivedTab.classList.remove('active');
                    }
                    
                    renderConversations(conversations);
                    
                    // Открываем тикет без изменения истории (используем внутреннюю функцию)
                    if (activeConversationId !== ticketId) {
                        selectConversation(ticketId);
                    }
                } else {
                    // Тикет не найден, редирект на список
                    history.replaceState({}, '', '/tickets');
                    hideChatPanel();
                }
            } else {
                // Путь /tickets - закрываем чат
                hideChatPanel();
            }
        });
        
        // Обработчики табов
        activeTab.addEventListener('click', () => {
            if (currentTab === 'active') return;
            currentTab = 'active';
            activeTab.classList.add('active');
            archivedTab.classList.remove('active');
            renderConversations(conversations);
        });
        
        archivedTab.addEventListener('click', () => {
            if (currentTab === 'archived') return;
            currentTab = 'archived';
            archivedTab.classList.add('active');
            activeTab.classList.remove('active');
            renderConversations(conversations);
        });
        
        loadConversations().then(() => {
            // После загрузки данных инициализируем роутинг
            initializeRouting();
        });
        initConversationsSocket();
    </script>
    <footer class="site-footer">
        <p>© 2025 Центр искусственного интеллекта СФУ</p>
    </footer>
</body>
</html>
